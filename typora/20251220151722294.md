

# React 工程化 

## JSX 渲染底层逻辑



**第一步：** 

​     把编写的jsx 语法，编译为虚拟**DOM对象** （框架内部构件的一套对象体系），基于这些属性描述出来，所构建视图中的DOM节点的相关特征



- 基于该语法包 

  ```json
  "bable": {
    "presets": [
      "react-app"
       ]
    }
  ```

  把jsx语法编译为 React.createElement(...)格式；格式如下参数：

- 再把creatElement 方法执行，创建出虚拟DOM对象

  ```jsx
  jsx 语法
  
  <>
     <h2 className="title" style={styObj}>hello world</h2>
     <div className="box">
              <span>{x}</span>
              <span>{y}</span>
     </div>
  </>
  
  编译为函数
  
  React.createElement(
  React.Fragment,
      null,
  React.createElement(
      "h2", { className: "title", style: sty0bj },  "\u73E0\u5CF0\u57F9\u8BAD"
  ),
  React.createElement( "div",{ className: "box"},
                      React.createElement("span", null, x), 
                      React.createElement( "span", null,  y))
  );
  
  渲染为虚拟DOM
  
  virtualDOM ={
     $$typeof: Symbol(react.element),
     ref: null,
     key: null,
     type: 标签名 或者组件
    // 存储了元素的相关属性 &&  字节点信息
     props:{
           元素的相关信息
           children: 子节点信息，若没有子节点则没有这属性
        }
  }
  
  把虚拟DOM 渲染为 真实DoM 
  v18
    const root=ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <>
        ...
      
      </>
  );
  ```

**第二步**：把虚拟DOM 渲染为真实DOM（浏览器页面中最后 渲染出阿里，让用户看见的ODM 元素）

> 补充说明： 第一次渲染页面是直接从虚拟DOM -> 真实DOM，但是后期视图更新的时候，需要经过一个DOM-DIFF 的对比，计算出补丁包PATCH （也就是两次视图差异部分）进行渲染

1. 第一次渲染完成后， 保存 虚拟DOM 缓存=> oldVirtualDOM
2. 按照最新的数据，把jsx重新编译为 ‘全新的virtualDom’ (全部重新编译一遍)，拿新的虚拟DOM 和之前缓存起来的虚拟DOM 进行对比 -> DOM-DIFF , 之后生成-> PATCH 补丁包， 再把该补丁包渲染



> 总结： jsx 语法通过调用语法包编译并创建createElement，然后执行该函数生成虚拟DOM ，最后通过render 将 虚拟DOM 渲染为真实DOM

## props 基本认识



- **props :** **属性是只读属性，不可以修改，原理是props 对象被冻结了**
  - 关于对象的规则设置
    - 冻结对象： Object.freeze(obj); 检查是否被冻结： Object.isFrozen(obj) => true/false
      - 被冻结对象，不能修改成员值、不能新增成员、删除现有成员、给成员做劫持 ( Object.defineProperty)
    - 密封
      - 检查被密封: Object.seal(obj) ; 检查是否被密封： Object.isSealed(obj)可以修改，其他操作不可做
    - 不可拓展； 把对象设置为不可拓展： Object.preventExtensions(obj)
      - 检查是否可拓展： Object.isExtensible(obj)
        - 被设置不可拓展对象： 除不能新增成员，其余的擦欧总都可以处理
- 作用： 父组件{index.jsx} 调用子组件{DemonOne.jsx}的时候，可以基于属性，把不同的信息传递给子组件，子组件接收响应的属性值，呈现不同的效果，让组件的复用性增强
  - 虽然对于传递过来的属性，不能直接修改，但是可以做一些规则校验
    - 通过把函数当作对象，设置静态的私有属性方法，来给其设置属性的校验规则
      - 通过函数组件.defaultProps = {} 设置
      - 设置其他规则，例如： 数据值格式、是否必传...... 依赖于这个插件 ： prop-types
        - 对应官网： [props](https://github.com/facebook/prop-types)
  - 被冻结对象，即是不可拓展，也是密封的，同理，被密封的对象，也是不可拓展的

## 插槽处理机制											



> 1. 传递数据值： 用属性
>2. **传递HTML结构： 用插槽**
> 
> - 工作原理：在 < Card > 和 < /Card > 之间的所有内容（元素、文本、甚至其他组件）都会被捆绑起来，作为一个**props.children**传递给Card 组件

JSX 中通过 {children} 决定这些内容应该被放置在何处。

- 这里放置的位置如何？ 需要将传递过来的children 做一个类型转化，React 内部提供了该功能
  - React 的实现方式是通过普通的 props 传递 JSX 元素，通过转化为数组通过下标定义
    - 你可以将任何 JSX 元素作为普通的 prop 传递给组件。这为你提供了极大的灵活性来定义多个“具名插槽”（如 header、body、footer）

```jsx
children = React.Children.toArray(children)
```



```jsx
// 定义组件 - Card.js
function Card({ children }) {
  return (
    <div className="card">
      <div className="card-content">
        {children} {/* 这就是“插槽”的位置 */}
      </div>
    </div>
  );
}

// 使用组件 - App.js
function App() {
  return (
    <Card>
      <h2>这是标题</h2> {/* 这些内容会作为 `children` 传入 Card 组件 */}
      <p>这是一些描述性的文字，会被注入到 Card 组件的 children 位置。</p>
    </Card>
  );
}
```

# 类组件（生命周期）

类组件的生命周期： 组件的挂载 -> 组件的更新 -> 组件的卸载 

- Mounting(挂载)：已插入真实 DOM
- Updating(更新)：正在被重新渲染
- Unmounting(卸载)：已移出真实 DOM!



old lifecycle

![old lifecycle](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12b2e35c8444f19b795b27e38f4c149~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)





new lifecycle

![new lifecycle](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7d8676f379d4d96bbf0ebd9a8528594~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)



废弃原因： 在v15的版本，更新过程是同步的，往往一个主线程长时间被占用，会导致页面性能问题；**React Fiber的机制:** 利用浏览器 `requestIdleCallback` 将可中断的任务进行分片处理，每一个小片的运行时间很短，这样唯一的线程就不会被独占



**对于states生命周期 更新来说**

1. shouldComponentUpdate(nextProps,nextState)
   - newState: 存储要修改的最新状态
   - this.state: 存储的还是修改前的状态，此时状态还没有改变
   - 该函数周期一般返回true ， 允许更新

2. 触发componentWillUpdate 周期函数： 更新之前
   - 此周期函数也是不安全的
   - 在这个阶段吗，状态还没有被修改

3. 修改状态值/属性值 让this.state.xxx 改为最新的值

4. 触发render 周期函数进行渲染
   - 按照最新的状态、属性，把返回的jsx 编译为虚拟DOM
   - 和第一次 渲染出来的虚拟DOM 进行对比 DOM-DIFF
   - 把差异的那分进行渲染 渲染为真实的DOM

5. 触发componentDidUpdate , 更新完毕

# Hooks 函数

## 状态管理

React组件分类

- **函数组件**
  - **不具备“状态、ref、周期函数”等内容**,第一次渲染完毕后,无法基于组件内部的操作来控制其更新,因此称之为静态组件!
  - 但是具备属性及插槽,父组件可以控制其重新渲染渲染流程简单,渲染速度较快!
  - 基于FP(函数式编程)思想设计,提供更细粒度的逻辑组织和复用!

- **类组件**
  - **具备“状态、ref、周期函数、属性、插槽”等内容**,可以灵活的控制组件更新,基于钩子函数也可灵活掌控不同阶段处理不同的事情!
  - 渲染流程繁琐,渲染速度相对较慢!基于OOP(面向对象编程)思想设计,更方便实现继承等!

react hook组件，就是基于react 中新提供 的hook 函数，可以让函数组件动态化

### setState 进阶





this.setState({partialState},{callback})

- partialState: 支持局部状态更改 

  ```jsx 
  this.setState({
      x:100  // 不论总共有多少状态，我们只修改了x,其余的状态不动
  })
  ```

  **callback**: 在状态更改/视图更新完毕后执行（也可以说只要执行了setState， callback 一定会执行）

  - 发生在componentDidUpdate 周期函数之后（componentDidUpdate 会在任何状态更改后都触发执行，而回调函数方式，可以在指定状态更新后处理）
  - 特殊，即使我们基于shouldComponentUpdate阻止了状态/视图更新，componentDidUpdate 周期函数肯定不会执行，但是我们设置的这个Callback 回调函数依然会被触发执行

```jsx

class Demo extends React.Component {
  state={
      x:10,
      y:4,
      z:1
  };
  handle=()=>{
      let{x,y,z} = this.state;
      this.setState({x:x+1});
      console.log(x);
      this.setState({y:y+1});
      console.log(y);
      this.setState({z:z+1});
      console.log(z);
  }
  render() {
      console.log("视图渲染")
      let {x,y,z} = this.state;
      return<div>
          x:{x}   -   y:{y}   -   z:{z}
          <br/>
          <button onClick={this.handle}>按钮</button>
      </div>
  }
}
```



如上 9~15行代码；当触发事件调用到该处函数时， 不会立即更新状态和视图而是将他加入到队列中（更新队列），当上下文中的代码都处理完毕后，会让更新队列中的任务，统一渲染或者更新一次（批处理）

涉及生命周期：

- shouldUpdate
- willUpdate
- this.setState.xxx
- render
- didUpdate
- callback   

当我们需要根据前两个参数更新后的值作为第三个参数的值时，这个时候react 提供了一个方法， 来自于 react-dom 中解构出来的 **flushSync**

- flushSync: 可以刷新 "updater 更新队列",也就是 让修改状态的任务立刻批处理一次！！！

### useState 处理机制 



> useState ： React Hook  函数之一；**目的是在函数组件中使用状态**，**并且后期基于状态的修改，可以让组件更新，类似于类组件中的setState**
>
> 
>
> ​             let [num,setNum] = useState(initialValue);
>
> 返回一个state,以及更新state 的函数

- 执行useState，传递的initialValue 是初始状态值，返回结果是一个数组：[状态值，修改状态的方法]

  - num 变量存储的是获取的状态值
  - setNum()变量存储的是修改状态的方法，并且会通知视图更新

  函数组件（或者Hooks 组件）不是类组件，所以没有实例的概念，调用组件不再是创建类的实例，而是把函数执行，产生与i给私有上下文而已，在所以，在函数组件中不涉及this 的处理

  

  

     

#### 处理机制



> 函数组件的每一次渲染（或者更新），都是把**函数重新执行**，产生全新的“私有上下文”
>
> - 内部的代码都需要重新执行一次
> - 涉及到的函数需要重新的构建，这些函数的作用域（私有上下文）是每一次执行的DEMO 产生的闭包
> - 每一次执行DEMO 函数，也会把useState 重新执行。
>   - 执行useState，只有第一次，设置的初始值会生效，其余以后再执行，获取的状态都是最新的状态值（而不是初始值）
>   - 返回的修改状态的方法，每一次都是返回一个新的     



![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251209204817802.png)

基本源码原理如下代码： 

```js
var _state;
function useState(initialValue){
    if(typeof  _state === "undefined") _state = initialValue;
    var setState=function setState(value){
        _state=value;
    };
    return [_state,setState];
}
```





![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251209211912376.png)



- 当我们在给对应的方法中加入计时器后，在规定的时间生效后会去上下文查找对应的变量值，并打印




#### 同步异步处理

 执行sueState: 把需要的状态信息都放在对象中统一管理

- 执行setState方法的时候，传递的是啥，就把状态“整体”改为啥值，并不会象类组件中的this.setState 一样，支持部分状态的更新
- 处理办法就是，将存储的值进行解构出来，通常 这样写  …state   
- 官方的建议是： 需要多个状态，就把useState执行多次即可  

![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213122854008.png)

1. 同步的话，需要使用flushSync 方法进行指定
2. 在react16 中，也和this.setState一样，放在合成事件&周期函数中，都是异步的操作，但是放在其他的异步操作中，（列如： 定时器，手动绑定的事件中等，它是同步的）

#### 函数更新和优化



useState 自带了性能优化的机制：

- 每一次修改状态值的时候，会拿最新要修改的值和之前的状态值做比较（基于object.is 作比较）
- 如果发现两次的值是一样的，则不会修改状态，也不会通知视图更新（可以理解为，类似于PureComponent，在shouldComponentUpdate 中做了浅比较和优化）
- usetState 方法中，也可以在该方法中包含写一个函数，
  -    ![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213133415955.png)
  - 该函数只在第一次初始化的时候执行，之后的操作中不再执行该方法
- 如下图所示，实际拿到的数据是11， 那如何实现累计呢，setXxx 方法中，需要将函数中的prev 进行累计返回即可

![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213125650745.png)



![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213130724776.png)





## 函数生命周期

### useEffect

> 作用： 在函数组件中，使用生命周期函数

- useEffect(callback): 没设置依赖
  - **第一次渲染完成后**，执行callback ，等价于 componentDidMount 
  - 在组件每一次更新完毕后，也会执行callback，等价于componentDidUpdate’
  - callback 中，获取的都是最新状态值
- useEffect(callback，[]):设置了，但是无依赖
  - **只有第一次渲染完毕后**，才会执行callback,每一次视图更新完毕后，callback 不再执行
  - 类似于，componentDidMount 
- useEffect(callback，[num]): 有依赖
  - 数组当中还可以放多个状态值，**第一次渲染完毕后**，执行callback，
  - 当依赖的状态值，或多个状态值中 的一个发生改变，也会触发callback 执行
  - 但依赖的状态如果没有改变，组件更新的时候callback 不会执行

- 如果 callback 返回了一个小函数，那么，该小函数会在第一次渲染完毕后把组件释放的时候把上一次返回的小函数执行


![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213141904694.png)







### uselayoutEffect  和 useEffect 的细节



- useEffect 必须在函数的最外层上下文中调用，不能把其嵌入到条件判断、循环等操作语句中
- useEffect 如果设置了返回值，则返回值必须是一个函数（代表组件销毁时触发）；如果经过async 修饰，返回都是一个实例，而不是函数
  -  此时，我们可以使用 Xxx.then(箭头函数)，即可忽略掉返回一个实例的问题  
  - 或者，在内部包括一个小函数 并执行该小函数![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213214030352.png)

如果链表中的callback 执行又修改了状态值（视图更新）

- 对于useEffect 来讲： 第一次真实DOM 已经渲染，组件更新会重新渲染真实的DOM
- 对于useLayoutEffect来讲，第一次真实DOM 还未渲染，遇到callback中修改了状态，视图立即更新，创建出来的虚拟DOM，然后和上一次的虚拟DOM 合并在一起渲染为真实DOM. 也就是此类场景下，真实DOM 只渲染一次，不会出现图像的闪烁
  -  useLayoutEffect 会阻塞浏览器渲染真实DOM（真实DOM 已经创建），优先执行Effect链表中的callback  

 useLayoutEffect 优先于useEffect  第一个首先输出更新

- useEffect: 浏览器肯定会把第一次的真实DOM 绘制了，再去渲染第二次真实DOM 
- useLayoutEffect: 浏览器是把两次真实DOM 的渲染，合并到一起渲染    



![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251213222326214.png)

视图更新步骤

1. 第一步： 基于 bable-preset-react-app 把jsx编译为createElement 格式
2. 把reacteElement 执行，创建出虚拟DOM
3. 基于root,render 方法把虚拟DOM 变为真实DOM 对象（DOM-DIFF）
   1. useLayoutEffect 阻塞第四步操作，先去执行Effect 链表中的方法（同步操作）
   2. useEffect 第四步操作和Effect链表中的方法执行，是同时进行的（异步操作） 
4. 浏览器渲染和绘制真实DOM 对象

## useRef & uselmperativeHandle 的使用



> 类组件中，我们基于ref 可以做的事情 ：
>
> 1. 赋值给一个标签，获取DOM 元素
> 2. 赋值给一个类子组件： 获取子组件实例（可以基于实例调用子组件中的属性和方法等）
> 3. 赋值给一个函数子组件： 报错（需要配合React.forwardRef 首先ref 转发，获取子组件中的某一个 DOM 元素）
>
> ref 的使用方式：
>
> - ref=‘box’; this.refs.box 获取（不推荐使用）
>
> - ref={x=>this.box=x}; this.box 获取
>
> - this.box=React.createRef(); 创建一个ref 对象
>
>   < ref={this.box}> this.box.current  获取DOM 元素

如何在函数中 使用ref 呢？

1. 基于 “ref={函数}” 的方式，可以把创建的DOM 元素（或者子组件的实例）赋值给box 变量
2. 也可以基于React.createRef() 创建一个ref 对象
3. 推荐使用useRef函数直接创建ref 对象，该方式也只能在函数组件中使用	 

​        let box=useRef(null)



- useRef ,  每一次在组件更新时，再一次执行该方法时，获取的还是第一次创建的对象（推荐使用）
- React.createRef(); 每一次在组件更新时，再一次执行该方法时，都会创建一个全新的ref 对象。比较狼垡资源





总结： 在类组件中，创建ref 对象，我们基于React.createRef 处理：但是在函数组件中，为了保证性能，我们应该使用专属的 useRef 处理



在父组件中调用子组件情况：

- 当调用的是函数子组件时： 需要将该函数组件放在React.forwardRef(函数组件名(props,ref)) 进行转发使用，父组件想要获取子组件中的某个元素可以直接在该属性上加入 ref={ref}

  -   **如果想获取子组件中的内部的属性和方法，需要使用useImperativeHandle（ref,()=>{return(返回的是什么都会被ref 对象获取到) }）**

- 当调用的时函数的类子组件时： 直接在函数父组件中 加入ref={子组件的变量或者属性} 即可获取对应 的子租价的属性和值

  

## useMemo 构建计算缓存



useMemo（callback,[依赖变量]）

- 第一次渲染的时候，callback 会执行，后期只有 依赖的状态发生变化，callback 才会再执行，每一次把callback 执行的返回结果赋值给 xxx
- useMemo 具备缓存的效果，再依赖的状态值没有改变，callback 没有 触发执行的时候，xx 获取的是上一次计算出来的结果（计算缓存）

![useMemo](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251215213620020.png)

- 作用：是一个优化的Hook 函数， 如果函数组件中，又消耗性能、时间的计算操作，则尽可能的使用useMemo 缓存起来设置对应的依赖


## usecallback缓存函数引用

> useCallback 用于得到一个固定引用值的函数，通常用它进行性能优化 其基本使用格式：
>
> ​       const cachedFn = useCallback(fn, dependencies)
>
> - 组件第一次渲染，useCallback 执行， 创建一个函数 callback  ，赋值给xxx
> - 组件后续每一次更新，判断依赖的状态值是否改变，如果改变，则重新创建新的函数堆，赋值给xxz， 如果没有改变或者没有设置依赖，则xxx获取的一直是第一次创建的函数堆，不会创建新的函数堆

**简单来讲： useCallback 可以保证，函数租金的每一次更新，不再把里面的小函数重新创建，用的都是第一次创建的**



useCallback不能乱用，并不是所有的租金内部的函数，都要其处理会更好

1. 虽然可以减少了堆内存的开辟，但是useCallback本省也有自己的处理逻辑和缓存机制，这个也消耗时间
2. 如何使用呢：
   1.  父组件嵌套子组件，父组件要把一个内部的函数，基于属性传给子组件，此时传入这个方法，我们基于useCallback 处理以下会更好 

诉求：

-  当父组件更新的时候，因为传递的子组件的属性仅仅是一个函数（特点：基本应该是不变的），所以不想再让子组件也跟着更新了
  - 第一条：传递的 子组件的属性（函数），每一次需要是相同的堆内存地址（是一致的），基于useCallback 处理
  - 第二条：在子组件内部也要做一个处理，验证父组件传递的属性是否发生改变，如果没有改变，则让子组件不能更新，有变化才需要更新，继承React.PureComponent 即可（shouldCompnentUpdate中对新老属性做了浅比较）  （该方法属于类组件）  ![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251217220539719.png)
  -  第三条：如果是函数组件，那么则是基于React.memo 函数，对新老传递的属性做比较，如果不一致，则执行函数组件，如果一致，则不让子组件更新  ![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251217221444795.png)

![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251217213729347.png)







![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251217220216532.png)









![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251217220341172.png)





## 自定义Hook提取公共逻辑

> 使用自定义hook 可以将某些组件逻辑提取到可重用的函数中










# 合成事件

==**语法是基于 onXxx={函数}进行事件绑定**==

**this值的处理**

- 当绑定的不再是箭头函数而是普通函数，当调用该普通函数时需要 使用this.xxx，此时**this 的值是undefined**而不是我们需要的对象或者实例本身；那**该如何解决**
  - 可以基于js中的bind 方法，预先处理函数中的this 和实参（this.普通函数.bind(this)）
    - 只要该方法进过 bind 处理了，那么最后一个实参，就是传递的合成事件对象
    - bind 还可以预先传参（通常传入的参数和实际参数个数不符合时，优先匹配最右侧信息）
  - 也可以直接使用箭头函数；代表了当前上下文的实例对象    
  - 或者也可以直接声明该函数为箭头函数   

**合成事件对象**

SyntheticBaseEvent 合成事件对象， react 内部特殊处理，把各个浏览器的事件对象统一化后，构建的一个事件对象

-   ```jsx
        handle2 = (ev) => {
            console.log(this);
            console.log(ev); // ev: SyntheticBaseEvent 
        };
    ```

- 合成事件对象中，也包含了浏览器内置事件对象中的一些属性和方法（常用的基本有）

  - clientx/clienty
  - pagex/pagey
  - target
  - type
  - preventDefault
  - stopPropagation
  - …..
  - nativeEvent: 基于这个属性，可以获取浏览器内置原生的事件对象

## 合成事件原理 - 事件传播

> - 例如： 一个容器中，很多元素都要在点击的时候做一些事情
>  - 事件委托： 只需要给容器 做一个事件绑定（点击内部的任何元素，根据事件的冒泡传播机制，都会让同期的点击事件也触发，我们在这里，根据**事件源**，做不同的事情就可以了）
>   - 限制：当前操作的事件必须支持冒泡传播机制才可以
>     - 例如： mouseenter / mouseleave 等事件美誉偶冒泡 传播机制的
>   - 如果单独做到事件绑定中，做了事件传播机制的阻止，那么事件委托中的操作也不会生效！！！



事件具备传播机制，例如：当触发inner 的点击行为的时候

1. 从最外层向最里层逐一查找（捕获阶段：分析出路径）
2. 把事件源（点击的这个元素）的点击行为触发（目标阶段）
3. 按照捕获阶段分析出来的路径，从里到外，把每一个元素的行为也触发（冒泡阶段）   

从这里也能看出事件的传播机制是： **先捕获后目标再冒泡**



- ev.stopPropation(): 阻止事件传播，包含捕获和冒泡
- ev.stopImmediatePropagation() :立刻阻止当前的事件的其他方法未执行的不再执行（同级）

## 合成事件原理-事件委托



> 事件委托： 
>
>   利用事件的传播机制，实现的一套事件绑定的处理方案；根据**事件源target**，做不同的的事情就可以了



优势：

- 提高JS 运行的性能，并且把处理的逻辑都集中到一起
- 某些需求必须基于事件委托处理，
- 给动态绑定的 元素做事件绑定

### 合成事件原理

> 合成事件处理原理：
>
> - “**绝对不是**”给当前元素基于addEventListener 单独做的事件绑定，React 中的合成事件，都是基于“**事件委托**” 机型处理
>   - 在react17及以后版本，都是委托给 #root 这个容器（捕获和冒泡都做了委托）
>   - 在17版本以前，都是委托给document 容器的（且只做了冒泡阶段的委托） 
>   - 对于没有事件传播机制的这样的一个事件，才是单独做事件绑定 ；例如： onMouseEnter \ onMouseLeave       



**在组件渲染的时候**,如果发现JSX元素属性中有 onXxx/onXxxCapture 这样的属性,不会给当前元素直接做事件绑定,只是把绑定的方法赋值给 元素的相关属性!!例如:

```jsx
outer.onClick=() => {console.log('outer 冒泡「合成」');}

outer.onClickCapture=() => {console.log('outer 捕获「合成」');}
```



DOM 零级事件绑定是 outer.**onclick**, 而上述是大写的outer.**onClick** 绑定，故此，他不是给当前元素基于addEventListener 单独做的事件绑定，而它是基于事件委托处理的

然后对#root这个容器做了事件绑定「捕获和冒泡都做了」

​    **原因:**因为组件中所渲染的内容,最后都会插入到#root容器中,这样点击页面中任何一个元素,最后都会把#root的点击行为触发!! 而在给#root绑定的方法中,把之前给元素设置的onXxx/onXxxCapture属性,在相应的阶段执行!!

**其基本执行源码如下所示：** 

```jsx
< script >

const root = document.querySelector('#root'),
      outer = document.querySelector('#outer'),
      inner = document.querySelector('#inner');

// 经过视图渲染解析,outer/inner上都有onXxx/onXxxCapture这样的属性

outer.onClick = () => { console.log('outer 冒泡「合成」')}
outer.onClickCapture = () => { console.log('outer 捕获「合成」')}
inner.onClick = () => {console.log('inner 冒泡「合成」')}
inner.onClickCapture = () => {console.log('inner 捕获「合成」')}

// 给#root做事件绑定
    
root.addEventListener('click', (ev) => {
    let path = ev.path; // path: [事件源->....->window] 所有祖先元素

    [...path].reverse().forEach(ele => {

        let handle = ele.onClickCapture;
        if (handle) handlex();  // handlex(),如果不经过处理，方法中的this 是undefined,如果是箭头函数，则找函数上下文中的this
      });
}, true);

root.addEventListener('click', (ev) => {
    let path = ev.path;

    path.forEach(ele => {

        let handle = ele.onClick;
        if (handle) handle();
       });
}, false);
    
</script>
```



1. 视图渲染的时候，遇到合成事件绑定并没有给元素做事件绑定而是给元素做了设置对应的属性（合成事件属性）
2. 给#root做了事件绑定 ，在#root 上绑定的方法执行，把所有规则的路径中，有合成事件属性的都执行即可（捕获和冒泡）



所谓合成事件绑定，其实并没有给元素本身做事件绑定，而是给元素设置 onXxx/onXxxCapture 这样的合成事件属性。当事件行为触发，根据原生事件传播机制，都会传播到#root 容器上， react 内部给#root 容器做了事件绑定（捕获&冒泡）

当react内部绑定的方法执行的时候，会根据ev.path 中分析的路径，依次把对应阶段的onXxx/onXxxCapture 等事件合成属性触发执行 ====> 合成事件是利用事件委托（事件传播机制）完成的！！！

![](https://raw.githubusercontent.com/Hashmite/PicGo/main/img/20251206224532766.png)

### 合成事件机制

1. ev.stoPropagation():  合成事件中的“阻止事件传播”, 阻止原生的事件传播 & 阻止合成事件中的事件传播。 
2. ev.nativeEvent.stopPropagation(); 原生事件对象中的“阻止事件传播”；只能阻止原生事件 的传播



在16版本中，合成事件的处理机制，不再是把事件委托给#root元素，而是委托给docuent 元素，并且只做了冒泡阶段的委托，在委托的方法中，把 onXxx/onXxxCapture 合成事件属性进行执行

​        

























# 组件通信

## 基于props 属性，实现父子组件通信























































































































































































































































































